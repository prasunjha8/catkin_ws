#!/usr/bin/env python3

import gym
from gym import spaces
import numpy as np
import rospy
import rosservice
from std_msgs.msg import Float64
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Imu
from gazebo_msgs.msg import ModelStates
from std_srvs.srv import Empty
import tf.transformations as tft
import math
import time

class BikeEnv(gym.Env):
    """Custom OpenAI Gym environment for the self-balancing bike in Gazebo."""
    metadata = {'render.modes': ['human']}

    def __init__(self):
        super(BikeEnv, self).__init__()
        
        rospy.init_node('bike_env', anonymous=True)

        # Action and Observation Space
        # Action: [rear_wheel_velocity, steering_angle]
        self.action_space = spaces.Box(low=-1.0, high=1.0, shape=(2,), dtype=np.float32)
        
        # Observation: 16 variables (see _get_obs method)
        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(16,), dtype=np.float32)

        # ROS Publishers and Subscribers
        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        rospy.Subscriber('/imu', Imu, self._imu_callback)
        rospy.Subscriber('/gazebo/model_states', ModelStates, self._model_states_callback)

        # ROS Services for simulation control
        rospy.wait_for_service('/gazebo/reset_simulation')
        self.reset_simulation_proxy = rospy.ServiceProxy('/gazebo/reset_simulation', Empty)
        self.unpause_proxy = rospy.ServiceProxy('/gazebo/unpause_physics', Empty)
        self.pause_proxy = rospy.ServiceProxy('/gazebo/pause_physics', Empty)
        
        # State variables
        self.roll = 0.0
        self.pitch = 0.0
        self.yaw = 0.0
        self.roll_rate = 0.0
        self.pitch_rate = 0.0
        self.yaw_rate = 0.0
        
        self.bike_pose = None
        self.bike_twist = None
        self.bike_model_index = -1
        
        self.steering_angle = 0.0
        self.rear_wheel_vel = 0.0

        # Target goal
        self.target_pos = np.array([10.0, 0.0]) # Target: 10m ahead on the x-axis
        self.prev_distance_to_goal = np.inf

        # Episode parameters
        self.step_count = 0
        self.max_steps = 2000

        rospy.loginfo("BikeEnv initialized.")

    def _imu_callback(self, data):
        orientation_q = data.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        (self.roll, self.pitch, self.yaw) = tft.euler_from_quaternion(orientation_list)
        
        self.roll_rate = data.angular_velocity.x
        self.pitch_rate = data.angular_velocity.y
        self.yaw_rate = data.angular_velocity.z

    def _model_states_callback(self, data):
        if self.bike_model_index == -1:
            try:
                self.bike_model_index = data.name.index('two_wheel_bike')
            except ValueError:
                # Bike model not found yet
                return
        
        self.bike_pose = data.pose[self.bike_model_index]
        self.bike_twist = data.twist[self.bike_model_index]

    def _get_obs(self):
        """
        Gathers the current state of the environment.
        Returns:
            np.array: A 16-dimensional observation vector.
        """
        if self.bike_pose is None or self.bike_twist is None:
            # Return a zero observation if data is not yet available
            return np.zeros(self.observation_space.shape[0])

        # 1. IMU Data (6)
        imu_data = [self.roll, self.pitch, self.yaw, self.roll_rate, self.pitch_rate, self.yaw_rate]
        
        # 2. Body Velocities (6)
        body_vel = [
            self.bike_twist.linear.x, self.bike_twist.linear.y, self.bike_twist.linear.z,
            self.bike_twist.angular.x, self.bike_twist.angular.y, self.bike_twist.angular.z
        ]

        # 3. Joint States (2)
        joint_states = [self.steering_angle, self.rear_wheel_vel]

        # 4. Target Information (2)
        current_pos = np.array([self.bike_pose.position.x, self.bike_pose.position.y])
        vector_to_goal = self.target_pos - current_pos
        distance_to_goal = np.linalg.norm(vector_to_goal)
        
        angle_to_goal = math.atan2(vector_to_goal[1], vector_to_goal[0])
        bearing = angle_to_goal - self.yaw
        # Normalize bearing to [-pi, pi]
        if bearing > math.pi:
            bearing -= 2 * math.pi
        if bearing < -math.pi:
            bearing += 2 * math.pi
            
        target_info = [distance_to_goal, bearing]

        # Concatenate all parts into a single observation vector
        obs = np.array(imu_data + body_vel + joint_states + target_info, dtype=np.float32)
        return obs

    def step(self, action):
        """
        Execute one time step within the environment.
        """
        rospy.wait_for_service('/gazebo/unpause_physics')
        try:
            self.unpause_proxy()
        except rospy.ServiceException as e:
            rospy.logerr(f"Unpause physics service call failed: {e}")

        # Scale actions from [-1, 1] to physical values
        # Action[0] -> Rear wheel velocity
        # Action[1] -> Steering angle
        self.rear_wheel_vel = action[0] * 10.0 # Max 10 rad/s
        self.steering_angle = action[1] * 0.785 # Max +/- 45 degrees

        # The diff_drive plugin uses linear.x for the left wheel and angular.z for the right.
        # We trick it to control our two joints.
        cmd = Twist()
        cmd.linear.x = self.rear_wheel_vel
        cmd.angular.z = self.steering_angle
        self.cmd_vel_pub.publish(cmd)
        
        # Let the simulation run for a short duration
        time.sleep(0.05)

        rospy.wait_for_service('/gazebo/pause_physics')
        try:
            self.pause_proxy()
        except rospy.ServiceException as e:
            rospy.logerr(f"Pause physics service call failed: {e}")

        self.step_count += 1
        
        obs = self._get_obs()
        done = False
        reward = self._compute_reward(obs)

        # Termination conditions
        if abs(self.roll) > 0.785: # Fallen over (45 degrees)
            rospy.logwarn("Bike fell over!")
            done = True
            reward = -200.0
        
        dist_to_goal = obs[14]
        if dist_to_goal < 0.5:
            rospy.loginfo("Goal reached!")
            done = True
            reward += 1000.0
            
        if self.step_count >= self.max_steps:
            rospy.loginfo("Max steps reached.")
            done = True

        return obs, reward, done, {}

    def _compute_reward(self, obs):
        """
        Calculate reward based on the current state.
        """
        # --- Component Rewards ---
        
        # 1. Balancing Reward (primary)
        # Exponentially decaying reward for staying upright
        reward_balance = math.exp(-10.0 * abs(self.roll))

        # 2. Forward Motion Reward
        # Reward for positive forward velocity
        forward_velocity = self.bike_twist.linear.x
        reward_forward = 0
        if forward_velocity > 0.1:
            reward_forward = 0.5 * np.clip(forward_velocity, 0, 2.0)

        # 3. Navigation Reward
        # Reward for getting closer to the goal
        current_distance_to_goal = obs[14]
        reward_nav = 10.0 * (self.prev_distance_to_goal - current_distance_to_goal)
        self.prev_distance_to_goal = current_distance_to_goal
        
        # 4. Control Effort Penalty
        # Penalize large actions to encourage smooth control
        action_penalty = -0.01 * (self.rear_wheel_vel**2 + self.steering_angle**2)

        # 5. Time Penalty
        # Encourage reaching the goal faster
        time_penalty = -0.1

        # --- Total Reward ---
        total_reward = (
            1.5 * reward_balance +
            0.5 * reward_forward +
            1.0 * reward_nav +
            0.1 * action_penalty +
            time_penalty
        )
        
        return total_reward

    def reset(self):
        """
        Reset the state of the environment to an initial state
        """
        rospy.wait_for_service('/gazebo/reset_simulation')
        try:
            self.reset_simulation_proxy()
        except rospy.ServiceException as e:
            rospy.logerr(f"Reset simulation service call failed: {e}")
        
        # Unpause simulation to allow sensors to publish
        rospy.wait_for_service('/gazebo/unpause_physics')
        try:
            self.unpause_proxy()
        except rospy.ServiceException as e:
            rospy.logerr(f"Unpause physics service call failed: {e}")

        time.sleep(0.1) # Wait for topics to update
        
        obs = self._get_obs()
        
        # Pause the simulation until the next step
        rospy.wait_for_service('/gazebo/pause_physics')
        try:
            self.pause_proxy()
        except rospy.ServiceException as e:
            rospy.logerr(f"Pause physics service call failed: {e}")

        self.step_count = 0
        current_pos = np.array([self.bike_pose.position.x, self.bike_pose.position.y])
        self.prev_distance_to_goal = np.linalg.norm(self.target_pos - current_pos)

        return obs

    def close(self):
        """
        Clean up the environment.
        """
        rospy.signal_shutdown("Closing BikeEnv")

if __name__ == '__main__':
    # This is for testing the environment standalone
    try:
        env = BikeEnv()
        obs = env.reset()
        rospy.loginfo("Environment reset.")
        for i in range(10):
            action = env.action_space.sample()
            obs, reward, done, info = env.step(action)
            rospy.loginfo(f"Step {i}: Reward={reward}, Done={done}")
            if done:
                obs = env.reset()
    except rospy.ROSInterruptException:
        pass




#!/usr/bin/env python3

import rospy
from stable_baselines3 import SAC
from stable_baselines3.common.callbacks import CheckpointCallback
from stable_baselines3.common.monitor import Monitor
from bike_env import BikeEnv
import os
import torch as th

def main():
    """
    Main function to initialize the environment, agent, and start training.
    """
    try:
        # 1. Initialize the Gym Environment
        env = BikeEnv()
        env = Monitor(env) # Recommended for monitoring training progress

        # 2. Define the RL Agent (SAC)
        
        # Custom Policy Network Architecture
        policy_kwargs = dict(
            activation_fn=th.nn.ReLU,
            net_arch=[256, 256] # Two hidden layers with 256 neurons each
        )
        
        # Directory for saving models and logs
        log_dir = "/tmp/gym/"
        os.makedirs(log_dir, exist_ok=True)
        model_path = os.path.join(log_dir, "sac_bike_model")

        # Callback for saving the model periodically
        checkpoint_callback = CheckpointCallback(
            save_freq=25000,
            save_path=log_dir,
            name_prefix="rl_model"
        )
        
        # Instantiate the SAC agent
        # We can load a pre-existing model or create a new one
        if os.path.exists(model_path + ".zip"):
            rospy.loginfo("Loading existing model...")
            model = SAC.load(model_path, env=env)
        else:
            rospy.loginfo("Creating a new model...")
            model = SAC(
                "MlpPolicy",
                env,
                verbose=1,
                learning_rate=0.0003,
                buffer_size=500000, # Smaller buffer to fit in memory
                batch_size=256,
                gamma=0.99,
                tau=0.005,
                ent_coef='auto',
                learning_starts=10000,
                policy_kwargs=policy_kwargs,
                tensorboard_log="./sac_bike_tensorboard/"
            )

        # 3. Start the Training Process
        rospy.loginfo("Starting training...")
        model.learn(
            total_timesteps=1000000,
            callback=checkpoint_callback,
            log_interval=1
        )

        # 4. Save the final trained model
        rospy.loginfo("Training finished. Saving final model.")
        model.save(model_path)

    except rospy.ROSInterruptException:
        pass
    finally:
        if 'env' in locals():
            env.close()
            rospy.loginfo("Environment closed.")

if __name__ == '__main__':
    main()


cmake_minimum_required(VERSION 3.0.2)
project(bike_rl_agent)

## Find catkin macros and libraries
find_package(catkin REQUIRED COMPONENTS
  rospy
)

## Declare Python scripts as executables
catkin_install_python(PROGRAMS
  scripts/train.py
  scripts/bike_env.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)



<?xml version="1.0"?>
<package format="2">
  <name>bike_rl_agent</name>
  <version>0.1.0</version>
  <description>The bike_rl_agent package contains the OpenAI Gym environment and training scripts for the self-balancing bike.</description>

  <maintainer email="user@todo.todo">user</maintainer>
  <license>TODO</license>

  <buildtool_depend>catkin</buildtool_depend>

  <exec_depend>rospy</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>geometry_msgs</exec_depend>
  <exec_depend>sensor_msgs</exec_depend>
  <exec_depend>gazebo_msgs</exec_depend>
  <exec_depend>python3-gym</exec_depend>
  <exec_depend>python3-numpy</exec_depend>
  <!-- Dependencies for Stable Baselines, PyTorch, etc., are expected to be installed via pip -->

  <export>
  </export>
</package>

<launch>
    <!-- Arguments -->
    <arg name="paused" default="false"/>
    <arg name="use_sim_time" default="true"/>
    <arg name="gui" default="true"/>
    <arg name="headless" default="false"/>
    <arg name="debug" default="false"/>
    <arg name="model" default="$(find two_wheel_bike_description)/urdf/bike.urdf.xacro"/>
    <arg name="world" default="$(find two_wheel_bike_description)/worlds/training_world.world"/>

    <!-- Launch Gazebo with the specified world -->
    <include file="$(find gazebo_ros)/launch/empty_world.launch">
        <arg name="world_name" value="$(arg world)"/>
        <arg name="paused" value="$(arg paused)"/>
        <arg name="use_sim_time" value="$(arg use_sim_time)"/>
        <arg name="gui" value="$(arg gui)"/>
        <arg name="headless" value="$(arg headless)"/>
        <arg name="debug" value="$(arg debug)"/>
    </include>

    <!-- Load the URDF model into the parameter server -->
    <param name="robot_description" command="$(find xacro)/xacro $(arg model)" />

    <!-- Spawn the robot in Gazebo -->
    <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model" args="-param robot_description -urdf -model two_wheel_bike -x 0 -y 0 -z 0.4" />

    <!-- Start robot state publisher -->
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" respawn="false" output="screen"/>

</launch>

<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="two_wheel_bike">

  <!-- Constants -->
  <xacro:property name="PI" value="3.1415926535897931"/>
  <xacro:property name="chassis_mass" value="15.0"/>
  <xacro:property name="wheel_mass" value="1.5"/>
  <xacro:property name="fork_mass" value="2.0"/>
  <xacro:property name="wheel_radius" value="0.3"/>
  <xacro:property name="wheel_width" value="0.08"/>
  <xacro:property name="chassis_length" value="1.2"/>
  <xacro:property name="chassis_height" value="0.4"/>
  <xacro:property name="chassis_width" value="0.1"/>
  <xacro:property name="fork_length" value="0.5"/>
  <xacro:property name="caster_angle" value="${PI/12}"/> <!-- 15 degrees -->

  <!-- Inertia Macros -->
  <xacro:macro name="box_inertia" params="m x y z">
    <inertial>
      <mass value="${m}"/>
      <inertia ixx="${m*(y*y+z*z)/12}" ixy="0" ixz="0" iyy="${m*(x*x+z*z)/12}" iyz="0" izz="${m*(x*x+y*y)/12}"/>
    </inertial>
  </xacro:macro>

  <xacro:macro name="cylinder_inertia" params="m r h">
    <inertial>
      <mass value="${m}"/>
      <inertia ixx="${m*(3*r*r+h*h)/12}" ixy="0" ixz="0" iyy="${m*(3*r*r+h*h)/12}" iyz="0" izz="${m*r*r/2}"/>
    </inertial>
  </xacro:macro>

  <!-- Base Link (Chassis) -->
  <link name="base_link">
    <visual>
      <origin xyz="0 0 ${wheel_radius + chassis_height/2}" rpy="0 0 0"/>
      <geometry>
        <box size="${chassis_length} ${chassis_width} ${chassis_height}"/>
      </geometry>
      <material name="blue">
        <color rgba="0.2 0.2 1.0 1.0"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 ${wheel_radius + chassis_height/2}" rpy="0 0 0"/>
      <geometry>
        <box size="${chassis_length} ${chassis_width} ${chassis_height}"/>
      </geometry>
    </collision>
    <xacro:box_inertia m="${chassis_mass}" x="${chassis_length}" y="${chassis_width}" z="${chassis_height}"/>
  </link>

  <!-- Rear Wheel -->
  <link name="rear_wheel_link">
    <visual>
      <origin xyz="0 0 0" rpy="${PI/2} 0 0"/>
      <geometry>
        <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
      </geometry>
      <material name="black">
        <color rgba="0.1 0.1 0.1 1.0"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="${PI/2} 0 0"/>
      <geometry>
        <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
      </geometry>
    </collision>
    <xacro:cylinder_inertia m="${wheel_mass}" r="${wheel_radius}" h="${wheel_width}"/>
  </link>

  <joint name="rear_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="rear_wheel_link"/>
    <origin xyz="-${chassis_length/2} 0 ${wheel_radius}" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
  </joint>

  <!-- Steering (Front Fork) -->
  <link name="front_fork_link">
    <visual>
        <origin xyz="${fork_length*sin(caster_angle)/2} 0 -${fork_length*cos(caster_angle)/2}" rpy="0 ${caster_angle} 0"/>
        <geometry>
            <box size="0.05 0.05 ${fork_length}"/>
        </geometry>
        <material name="grey">
            <color rgba="0.5 0.5 0.5 1.0"/>
        </material>
    </visual>
    <collision>
        <origin xyz="${fork_length*sin(caster_angle)/2} 0 -${fork_length*cos(caster_angle)/2}" rpy="0 ${caster_angle} 0"/>
        <geometry>
            <box size="0.05 0.05 ${fork_length}"/>
        </geometry>
    </collision>
    <xacro:box_inertia m="${fork_mass}" x="0.05" y="0.05" z="${fork_length}"/>
  </link>

  <joint name="steering_joint" type="revolute">
    <parent link="base_link"/>
    <child link="front_fork_link"/>
    <origin xyz="${chassis_length/2} 0 ${wheel_radius + chassis_height/2}" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <limit lower="-0.785" upper="0.785" effort="10" velocity="10"/>
  </joint>

  <!-- Front Wheel -->
  <link name="front_wheel_link">
    <visual>
      <origin xyz="0 0 0" rpy="${PI/2} 0 0"/>
      <geometry>
        <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
      </geometry>
      <material name="black"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="${PI/2} 0 0"/>
      <geometry>
        <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
      </geometry>
    </collision>
    <xacro:cylinder_inertia m="${wheel_mass}" r="${wheel_radius}" h="${wheel_width}"/>
  </link>

  <joint name="front_wheel_joint" type="continuous">
    <parent link="front_fork_link"/>
    <child link="front_wheel_link"/>
    <origin xyz="${fork_length*sin(caster_angle)} 0 -${fork_length*cos(caster_angle)}" rpy="0 ${caster_angle} 0"/>
    <axis xyz="0 1 0"/>
  </joint>

  <!-- Gazebo Plugins -->
  <gazebo>
    <!-- IMU Sensor -->
    <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">
      <ros>
        <namespace>/</namespace>
        <remapping>~/out:=imu</remapping>
      </ros>
      <initial_orientation_as_reference>false</initial_orientation_as_reference>
    </plugin>
  </gazebo>
  
  <gazebo reference="base_link">
    <sensor name="imu_sensor" type="imu">
      <always_on>true</always_on>
      <update_rate>100</update_rate>
    </sensor>
    <material>Gazebo/Blue</material>
  </gazebo>
  
  <gazebo>
    <!-- Motor and Steering Controller -->
    <plugin name="differential_drive_controller" filename="libgazebo_ros_diff_drive.so">
        <ros>
            <namespace>/</namespace>
            <remapping>cmd_vel:=cmd_vel</remapping>
            <remapping>odom:=odom</remapping>
        </ros>

        <!-- We map rear wheel to left_joint and steering to right_joint -->
        <left_joint>rear_wheel_joint</left_joint>
        <right_joint>steering_joint</right_joint> <!-- This is a trick to control steering -->

        <wheel_separation>1.0</wheel_separation> <!-- This value is not used for physics, but required by plugin -->
        <wheel_diameter>${2*wheel_radius}</wheel_diameter>
        
        <max_wheel_torque>20</max_wheel_torque>
        <max_wheel_acceleration>1.0</max_wheel_acceleration>

        <publish_odom>true</publish_odom>
        <publish_odom_tf>true</publish_odom_tf>
        <publish_wheel_tf>true</publish_wheel_tf>

        <odometry_frame>odom</odometry_frame>
        <robot_base_frame>base_link</robot_base_frame>
    </plugin>
  </gazebo>

</robot>

<?xml version="1.0" ?>
<sdf version="1.6">
  <world name="default">
    <!-- A ground plane -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- A global light source -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Physics Engine Settings -->
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>

    <!-- Scene Settings -->
    <scene>
      <ambient>0.4 0.4 0.4 1</ambient>
      <background>0.7 0.7 0.7 1</background>
      <shadows>true</shadows>
    </scene>

    <!-- Spherical Coordinates -->
    <spherical_coordinates>
      <surface_model>EARTH_WGS84</surface_model>
      <latitude_deg>0</latitude_deg>
      <longitude_deg>0</longitude_deg>
      <elevation>0</elevation>
      <heading_deg>0</heading_deg>
    </spherical_coordinates>

  </world>
</sdf>
cmake_minimum_required(VERSION 3.0.2)
project(two_wheel_bike_description)

find_package(catkin REQUIRED)

catkin_package()

install(DIRECTORY launch worlds urdf
  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
)

<?xml version="1.0"?>
<package format="2">
  <name>two_wheel_bike_description</name>
  <version>0.1.0</version>
  <description>The two_wheel_bike_description package contains the URDF, world, and launch files for the self-balancing bike simulation.</description>

  <maintainer email="user@todo.todo">user</maintainer>
  <license>TODO</license>

  <buildtool_depend>catkin</buildtool_depend>

  <depend>roslaunch</depend>
  <depend>robot_state_publisher</depend>
  <depend>gazebo_ros</depend>
  <depend>xacro</depend>

  <export>
  </export>
</package>
